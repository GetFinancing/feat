#!/usr/bin/python
# -*- Mode: Python -*-
# vi:si:et:sw=4:sts=4:ts=4

# F3AT - Flumotion Asynchronous Autonomous Agent Toolkit
# Copyright (C) 2010,2011 Flumotion Services, S.A.
# All rights reserved.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

# See "LICENSE.GPL" in the source distribution for more information.

# Headers in this file shall remain intact.


import commands
import glob
import optparse
import os
import sys
import time

from feat.common import run, signal, text_helper, log
from feat.configure import configure

from feat.agencies.net import options, config, configfile


def start(args):
    debug = os.environ.get("FEAT_DEBUG", "3")
    feat = os.path.join(configure.bindir, 'feat')
    confile = os.path.join(configure.confdir, 'feat.ini')
    cmd = "%s -C %s -d %s" % (feat, confile, debug)
    localfile = os.path.join(configure.confdir, 'local.ini')
    if os.path.exists(localfile):
        # add local.ini if it exists
        cmd += " -C " + localfile
    cmd = " ".join([cmd] + args)

    stdout("Starting feat ")
    status, output = commands.getstatusoutput(cmd)
    if status != 0:
        print >> sys.stderr, ("Running command:\n %s\n failed with the "
                              "status code %d." % (cmd, status))
        print >> sys.stderr, "The command output:\n\n", output
        if os.WIFEXITED(status):
            sys.exit(os.WEXITSTATUS(status))

    _pidfile_wait(exists=True, timeout=5)
    return


def stop(sig=signal.SIGUSR1):
    stdout("Stopping feat ")
    rundir = configure.rundir
    pid = run.get_pid(rundir)
    if pid is None:
        print >> sys.stderr, "PID file not found!"
        sys.exit(1)
    if not run.signal_pid(pid, sig):
        print >> sys.stderr, "Process with PID %d not found!" % (pid, )
        sys.exit(1)
    _pidfile_wait(exists=False, timeout=10)
    return


def main(args):
    usage = text_helper.format_block("""
    Usage: feat {start|stop|shutdown|restart|status|clean} [extra_options]

    Commands:
    * start - Start the service
    * stop - Stop the service violently, the agents will be migrated to
             different hosts once the monitor agent running on the other
             machine figures out they are gone.
    * shutdown - Stop service in a gentle way, cleaning up the agents data.
    * restart - Stop service gently and start it back.
    * status - Checks if the service is running.
    * clean - Cleans the log and rundir.
    * hostcleanup - Cleans up descriptors of the agents running on the host.
    """)

    try:
        command = args.pop(0)
    except IndexError:
        print usage
        sys.exit(1)

    if command == 'start':
        rundir = configure.rundir
        pid = run.get_pid(rundir)
        if pid:
            print >> sys.stderr, "Feat seems to be running with pid", pid
            print >> sys.stderr, "Consider removing the pidfile."
            sys.exit(1)
        start(args)
        return

    if command == 'stop':
        stop(signal.SIGUSR1)
        return

    if command == 'shutdown':
        stop(signal.SIGUSR2)
        return

    if command == 'restart':
        stop(signal.SIGUSR2)
        start(args)
        return

    if command == 'status':
        run.status(processName='', rundir=configure.rundir)
        return

    if command == 'clean':
        c = _parse_config()
        to_delete = []
        to_delete.extend(glob.glob(os.path.join(c.agency.rundir, "*.log")))
        to_delete.extend(glob.glob(os.path.join(c.agency.rundir, "*.sqlite3")))
        to_delete.extend(glob.glob(os.path.join(c.agency.logdir, "*.log")))
        to_delete.extend(glob.glob(os.path.join(c.agency.logdir, "*.sqlite3")))
        for name in set(to_delete):
            print "Deleting ", name
            try:
                os.unlink(name)
            except OSError:
                pass
        return

    if command == 'hostcleanup':
        from feat import applications

        c = _parse_config()

        # parse extra options
        parser = optparse.OptionParser()
        parser.add_option('--hostname',
                          help=('specify the hostname for which for perform '
                                'the cleanup'),
                          action='store', default=c.agency.hostname,
                          type="str", metavar="HOSTNAME", dest='hostname')

        opts, _ = parser.parse_args(args)

        applications.load('feat.agents.application', 'feat')
        from feat.utils import host_restart
        from feat.agents.base import dbtools

        log.FluLogKeeper.init()
        log.set_default(log.FluLogKeeper())
        with dbtools.dbscript(c.db) as d:
            d.addCallback(host_restart.do_cleanup, opts.hostname)
        return

    stderr("No such command, %s" % (command, ))
    stderr(usage)
    sys.exit(1)


def stdout(msg):
    sys.stdout.write(msg)
    sys.stdout.flush()


def stderr(msg):
    sys.stderr.write(msg)
    sys.stderr.flush()


def _parse_config():
    parser = optparse.OptionParser()
    options.add_options(parser)
    opts, args = parser.parse_args([])
    feat_ini = os.path.join(configure.confdir, 'feat.ini')
    local_ini = os.path.join(configure.confdir, 'local.ini')
    with open(feat_ini, 'r') as f:
        configfile.parse_file(parser, f)
    if os.path.exists(local_ini):
        with open(local_ini, 'r') as f:
            configfile.parse_file(parser, f)

    c = config.Config()
    c.load(os.environ, opts)
    return c


def _pidfile_wait(exists, timeout):
    elapsed = 0
    seconds = 0
    while _pidfile_exist() is not exists:
        time.sleep(0.1)
        elapsed += 0.1
        if int(elapsed) > seconds:
            stdout('.')
            seconds = int(elapsed)
        if elapsed > timeout:
            stderr("Timeout waiting.\n")
            sys.exit(1)
    stdout("done.\n")


def _pidfile_exist():
    return not not run.get_pid(configure.rundir)


if __name__ == '__main__':
    # initializing log is necessary for methods defined
    # in feat.common.run module
    keeper = log.VoidLogKeeper()
    log.set_default(keeper)
    main(sys.argv[1:])
