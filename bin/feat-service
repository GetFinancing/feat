#!/usr/bin/python
# -*- Mode: Python -*-
# vi:si:et:sw=4:sts=4:ts=4

# F3AT - Flumotion Asynchronous Autonomous Agent Toolkit
# Copyright (C) 2010,2011 Flumotion Services, S.A.
# All rights reserved.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

# See "LICENSE.GPL" in the source distribution for more information.

# Headers in this file shall remain intact.
import commands
import glob
import logging
import optparse
import os
import sys
import time
import warnings

from feat.common import run, signal, text_helper, log, defer
from feat.configure import configure
from feat.gateway import client as gateway_client

from feat.agencies.net import config


def start(args):
    debug = os.environ.get("FEAT_DEBUG", "3")
    feat = os.path.join(configure.bindir, 'feat')
    confile = os.path.join(configure.confdir, 'feat.ini')
    cmd = "%s -C %s -d %s" % (feat, confile, debug)
    localfile = os.path.join(configure.confdir, 'local.ini')
    if os.path.exists(localfile):
        # add local.ini if it exists
        cmd += " -C " + localfile
    cmd = " ".join([cmd] + args)
    cmd += " >> %s 2>&1" % os.path.join(configure.logdir, 'feat-service.log')

    logger.info("Starting feat")
    logger.debug("Executing %s" % cmd)
    status, output = commands.getstatusoutput(cmd)
    if status != 0:
        logger.error("Running command:\n %s\n failed with the "
                  "exit code %d.", cmd, status)
        logger.error("The command output:\n%s", output)
        return status

    return _pidfile_wait(exists=True, timeout=5)


def stop(sig=signal.SIGUSR1):
    logger.debug("Stopping feat ")
    rundir = configure.rundir
    pid = run.get_pid(rundir)
    if pid is None:
        logger.error("PID file not found!")
        return 1
    if not run.signal_pid(pid, sig):
        logger.error("Process with PID %d not found!", pid)
        return 1
    return _pidfile_wait(exists=False, timeout=30)


def main(args):
    usage = text_helper.format_block("""
    Usage: feat {start|stop|shutdown|restart|status|clean|hostclean} [extra_options]

    Commands:
    * start - Start the service
    * stop - Stop the service violently, the agents will be migrated to
             different hosts once the monitor agent running on the other
             machine figures out they are gone.
    * shutdown - Stop service in a gentle way, cleaning up the agents data.
    * restart - Stop service gently and start it back.
    * status - Checks if the service is running.
    * clean - Cleans the log and rundir.
    * hostclean - Cleans up descriptors of the agents running on the host.
    * agentrestart - Restarts a statically configured agent.
    """)

    try:
        command = args.pop(0)
    except IndexError:
        print usage
        sys.exit(1)

    if command == 'start':
        rundir = configure.rundir
        pid = run.get_pid(rundir)
        if pid:
            logger.error("Not starting feat because it seems to be running"
                         " with pid: %s. "
                         "Consider removing the pidfile", pid)
            sys.exit(1)
        sys.exit(start(args))

    if command == 'stop':
        sys.exit(stop(signal.SIGUSR1))

    if command == 'shutdown':
        sys.exit(stop(signal.SIGUSR2))

    if command == 'restart':
        stop(signal.SIGUSR2) # ignore the result of stop
        sys.exit(start(args))

    if command == 'status':
        run.status(processName='', rundir=configure.rundir)
        sys.exit(0)

    if command == 'clean':
        c = config.parse_service_config()
        to_delete = []
        to_delete.extend(glob.glob(os.path.join(c.agency.rundir, "*.log")))
        to_delete.extend(glob.glob(os.path.join(c.agency.rundir, "*.sqlite3")))
        to_delete.extend(glob.glob(os.path.join(c.agency.logdir, "*.log")))
        to_delete.extend(glob.glob(os.path.join(c.agency.logdir, "*.sqlite3")))

        # cleanup also the stale pidfile
        pid = run.get_pid(configure.rundir)
        if pid:
            if not run.check_pid_running(pid):
                logger.debug("Cleaning up stale pidfile.")
                to_delete.append(
                    run.get_pidpath(configure.rundir, run.PROCESS_TYPE))
            else:
                logger.debug("Not cleaning up pidfile because process is "
                             "running with pid: %s", pid)

        for name in set(to_delete):
            logger.debug("Deleting %s", name)
            try:
                os.unlink(name)
            except OSError:
                pass
        return

    if command in ['hostclean', 'hostcleanup']:
        from feat import applications

        c = config.parse_service_config()

        # parse extra options
        parser = optparse.OptionParser()
        parser.add_option('--hostname',
                          help=('specify the hostname for which for perform '
                                'the cleanup'),
                          action='store', default=c.agency.full_hostname,
                          type="str", metavar="HOSTNAME", dest='hostname')
        parser.add_option('--dbname',
                          help=('specify the name of database to perform '
                                'the cleanup on'),
                          action='store', default=c.db.name,
                          type="str", metavar="NAME", dest='dbname')

        opts, _ = parser.parse_args(args)

        logger.info("Performing host cleanup for host %s", opts.hostname)
        applications.load('feat.agents.application', 'feat')
        from feat.utils import host_restart
        from feat.database import tools

        c.db.name = opts.dbname
        with tools.dbscript(c.db) as d:
            d.addCallback(host_restart.do_cleanup, opts.hostname)
        return

    if command == 'agentrestart':
        c = config.parse_service_config()
        # for compatibility, still accept -n to pass the name
        parser = optparse.OptionParser()
        parser.add_option('-n', '--static-name',
                          help='Name of static agent to restart',
                          action='store',
                          type="str", metavar="NAME", dest='static_name')

        opts, args = parser.parse_args(args)
        if not args:
            if not opts.static_name:
                logger.error("Please specify the name of a statically "
                    "configured agent to restart.")
                sys.exit(1)
            args = [opts.static_name, ]
            warnings.warn(
                "The agent name is not optional.  Specify it as an argument.",
                DeprecationWarning)

        from feat.web import security
        sp = security.ClientPolicy(
            security.ClientContextFactory(p12_filename=c.gateway.client_p12))
        client = gateway_client.Client(sp, logger=log.VoidLogKeeper())
        sys.exit(_gateway_script(agent_restart, client, args[0], c))


    logger.error("No such command, %s", command)
    print >> sys.stderr, usage
    sys.exit(1)


@defer.inlineCallbacks
def agent_restart(client, static_name, config):
    logger.info("I'm about to restart statically configured agent: %s",
                static_name)
    hostname = config.agency.full_hostname
    port = config.gateway.port

    context = dict(hostname=hostname, static_name=static_name)
    path = '/agents/%(hostname)s/static_agents' % context
    status, static = yield client.get(hostname, port, path)
    if status == 404:
        logger.error(
            "Got 404 response fetching info about static agents. "
            "This most likely means that the Host Agent is not running.")
        defer.returnValue(1)
    if static_name not in static:
        logger.error(
            "Host agent doesn't know about this static agent. Known static "
            "agents are: '%s'", "', '".join(static.keys()))
        defer.returnValue(1)

    path = '/agents/%(hostname)s/static_agents/%(static_name)s' % context
    status, info = yield client.get(hostname, port, path)
    if 'running' not in info:
        logger.error("Got wrong response from gateway location: %s"
                     "%r", path, info)
        defer.returnValue(1)

    if info['running']:
        agent_id = info['agent_id']
        logger.info("Agent has ID: %s and will be shut down", agent_id)
        shutdown = '/agents/%s/_shutdown' % (agent_id, )
        status, r = yield client.delete(hostname, port, shutdown)
        if r['type'] != 'deleted':
            logger.error("Response for shutdown call: %r", r)
    logger.info('About to start the agent %s.', static_name)
    status, r = yield client.post(hostname, port, path + '/_start', force=True)
    if status == 200 and isinstance(r, dict) and r.get('type') == 'done':
        logger.info("Done")
        defer.returnValue(0)
    else:
        logger.error("Got response starting agent: %r", r)
        defer.returnValue(1)


def _gateway_script(method, client, *args, **kwargs):
    from twisted.internet import reactor
    from feat.common import error

    def set_exitcode(res, context):
        context['exitcode'] = res

    def error_handler(fail):
        from feat.extern.log import log as xlog
        xlog.setDebug('4')
        log.set_default(log.PythonLogKeeper(logger))
        error.handle_failure(None, fail,
                             'Agent restart failed with: ')
        context['exitcode'] = 1

    context = dict()
    d = defer.Deferred()
    d.addCallback(method, *args, **kwargs)
    d.addCallback(set_exitcode, context)
    d.addErrback(error_handler)
    d.addBoth(defer.drop_param, reactor.stop)
    reactor.callWhenRunning(d.callback, client)
    reactor.run()
    return context['exitcode']


def _pidfile_wait(exists, timeout):
    elapsed = 0
    seconds = 0
    while _pidfile_exist() is not exists:
        time.sleep(0.1)
        elapsed += 0.1
        if int(elapsed) > seconds:
            seconds = int(elapsed)
        if elapsed > timeout:
            verb = 'appear' if exists else 'dissapear'
            logger.error("Timeout waiting for the pidfile to %s.\n", verb)
            return 1
    return 0


def _pidfile_exist():
    return not not run.get_pid(configure.rundir)


def _prepare_logging():
    # prepare logger
    logger = logging.getLogger('feat-service')
    logger.setLevel(logging.DEBUG)

    # log to file
    path = os.path.join(configure.logdir, 'feat-service.log')
    handler = logging.FileHandler(path)
    handler.setFormatter(logging.Formatter(
        '[%(asctime)s] [%(levelname)s] %(message)s'))
    logger.addHandler(handler)

    # log INFO and higher to sys.stderr
    logger = logging.getLogger('feat-service')
    logger.setLevel(logging.INFO)

    handler = logging.StreamHandler(sys.stderr)
    handler.setFormatter(logging.Formatter('%(message)s'))
    logger.addHandler(handler)

    # initializing feat log is necessary for methods defined
    # in feat.common.run module
    keeper = log.VoidLogKeeper()
    # #line below allows keeping feat logger output
    # keeper = log.PythonLogKeeper(logger)
    log.set_default(keeper)
    return logger

logger = _prepare_logging()


if __name__ == '__main__':
    try:
        main(sys.argv[1:])
    except Exception:
        logger.error("Fatal error running feat-service", exc_info=True)
